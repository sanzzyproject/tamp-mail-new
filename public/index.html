<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#F2F4F8"> <title>Temp Mail SANN404</title>
    
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/732/732200.png">
    
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    ```

### 2. Update `public/script.js`
Ini adalah **update besar** pada logikanya. Saya menghapus logika `localStorage` dan menggantinya dengan **IndexedDB**. Email akan disimpan permanen di browser sampai kamu generate email baru.

Hapus semua isi `script.js` lama, ganti dengan ini:

```javascript
let currentEmail = localStorage.getItem('sann404_mail') || null;
let db; // Variable untuk menyimpan koneksi IndexedDB

// --- KONFIGURASI INDEXED DB ---
const DB_NAME = 'SannMailDB';
const DB_VERSION = 1;
const STORE_NAME = 'messages';

// Init Aplikasi
document.addEventListener('DOMContentLoaded', async () => {
    await initDB(); // Buka Database dulu
    
    // Register PWA Service Worker
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js')
            .then(() => console.log('Service Worker Registered'))
            .catch(err => console.log('SW Fail:', err));
    }

    if (currentEmail) {
        document.getElementById('emailAddress').innerText = currentEmail;
        await loadCachedMessages(); // Tampilkan pesan tersimpan LANGSUNG!
        fetchInbox(); // Lalu cek update baru ke server
    } else {
        generateNewEmail();
    }
    
    startAutoRefresh();
});

// --- FUNGSI DATABASE (IndexedDB) ---
function initDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onupgradeneeded = (e) => {
            db = e.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                // Keypath menggunakan gabungan waktu+pengirim agar unik
                db.createObjectStore(STORE_NAME, { keyPath: 'id' });
            }
        };

        request.onsuccess = (e) => {
            db = e.target.result;
            resolve(db);
        };
        
        request.onerror = (e) => reject(e);
    });
}

function saveMessageToDB(msg) {
    return new Promise((resolve) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        store.put(msg); // put = simpan atau update jika ada
        tx.oncomplete = () => resolve();
    });
}

function getAllMessagesFromDB() {
    return new Promise((resolve) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.getAll();
        request.onsuccess = () => resolve(request.result || []);
    });
}

function clearAllMessagesDB() {
    return new Promise((resolve) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        store.clear();
        tx.oncomplete = () => resolve();
    });
}

// --- LOGIKA APLIKASI ---

function switchTab(viewId, element) {
    document.querySelectorAll('.tab-view').forEach(el => el.classList.remove('active'));
    document.getElementById(viewId).classList.add('active');
    
    if(element) { 
        document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
        element.classList.add('active');
    }
}

async function confirmNewEmail() {
    if(confirm('Buat email baru? Inbox lama akan dihapus permanen.')) {
        generateNewEmail();
    }
}

async function generateNewEmail() {
    const emailDisplay = document.getElementById('emailAddress');
    emailDisplay.innerText = "Membuat ID baru...";
    
    await clearAllMessagesDB(); // Hapus database lama
    updateBadge(0);
    
    try {
        const res = await fetch('/api?action=generate');
        const data = await res.json();
        
        if (data.success) {
            currentEmail = data.result.email;
            localStorage.setItem('sann404_mail', currentEmail);
            emailDisplay.innerText = currentEmail;
            
            document.getElementById('unreadList').innerHTML = emptyState('updates');
            document.getElementById('readList').innerHTML = emptyState('inbox');
            
            switchTab('view-home', document.querySelector('.nav-item:first-child'));
        } else {
            alert('Gagal: ' + data.result);
        }
    } catch (e) {
        emailDisplay.innerText = "Error Jaringan";
    }
}

async function loadCachedMessages() {
    const messages = await getAllMessagesFromDB();
    renderMessages(messages);
}

async function fetchInbox() {
    if (!currentEmail) return;

    try {
        const res = await fetch(`/api?action=inbox&email=${currentEmail}`);
        const data = await res.json();

        if (data.success && data.result.inbox) {
            const serverMessages = data.result.inbox;
            
            // Simpan pesan baru ke DB tanpa menimpa status 'read' yang sudah ada
            // Kita cek dulu DB yang ada
            const existingMessages = await getAllMessagesFromDB();
            
            for (const msg of serverMessages) {
                const msgId = `${msg.created}_${msg.from}`.replace(/\s/g, '');
                
                // Cek apakah pesan ini sudah ada di DB
                const exists = existingMessages.find(m => m.id === msgId);
                
                if (!exists) {
                    // Jika pesan baru, simpan dengan status unread
                    await saveMessageToDB({ ...msg, id: msgId, isRead: false });
                }
                // Jika sudah ada, jangan lakukan apa-apa agar status 'read' tidak tertimpa
            }
            
            // Refresh tampilan dari DB
            await loadCachedMessages();
        }
    } catch (e) {
        console.log("Offline atau Error Fetch");
    }
}

function renderMessages(messages) {
    const unreadContainer = document.getElementById('unreadList');
    const readContainer = document.getElementById('readList');
    
    let unreadHTML = '';
    let readHTML = '';
    let unreadCount = 0;

    // Sort pesan biar yang terbaru di atas
    messages.sort((a, b) => new Date(b.created) - new Date(a.created));

    messages.forEach((msg) => {
        // Render HTML
        const html = `
            <div class="message-card ${msg.isRead ? 'read' : 'unread'}" onclick="openMessage('${msg.id}')">
                <div class="msg-top">
                    <span class="msg-from">${msg.from}</span>
                    <span class="msg-time">${msg.created}</span>
                </div>
                <div class="msg-subject">${msg.subject || '(Tanpa Subjek)'}</div>
                <div class="msg-snippet">${msg.message}</div>
            </div>
        `;

        if (msg.isRead) {
            readHTML += html;
        } else {
            unreadHTML += html;
            unreadCount++;
        }
    });

    unreadContainer.innerHTML = unreadHTML || emptyState('updates');
    readContainer.innerHTML = readHTML || emptyState('inbox');
    
    updateBadge(unreadCount);
}

async function openMessage(msgId) {
    const messages = await getAllMessagesFromDB();
    const msg = messages.find(m => m.id === msgId);
    
    if (!msg) return;

    // Isi Modal
    document.getElementById('modalSubject').innerText = msg.subject || '(No Subject)';
    document.getElementById('modalFrom').innerText = msg.from;
    document.getElementById('modalTime').innerText = msg.created;
    document.getElementById('modalBody').innerText = msg.message;
    
    const modal = document.getElementById('msgModal');
    modal.classList.add('show');

    // Update status jadi READ di DB
    if (!msg.isRead) {
        msg.isRead = true;
        await saveMessageToDB(msg); // Update DB
        await loadCachedMessages(); // Refresh UI background
    }
}

function closeModal() {
    document.getElementById('msgModal').classList.remove('show');
}

function updateBadge(count) {
    const badge = document.getElementById('badge-count');
    const dot = document.getElementById('nav-dot');
    
    if (count > 0) {
        badge.innerText = count;
        badge.style.display = 'inline-block';
        dot.style.display = 'block';
    } else {
        badge.style.display = 'none';
        dot.style.display = 'none';
    }
}

function emptyState(type) {
    const icon = type === 'updates' ? 'bi-bell-slash' : 'bi-inbox';
    const text = type === 'updates' ? 'Belum ada pesan baru.' : 'Belum ada pesan terbaca.';
    return `
        <div class="empty-placeholder">
            <i class="bi ${icon}"></i>
            <p>${text}</p>
        </div>
    `;
}

function copyEmail() {
    if (!currentEmail) return;
    navigator.clipboard.writeText(currentEmail);
    const toast = document.getElementById('toast');
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 2000);
}

function startAutoRefresh() {
    let timeLeft = 10;
    const timerText = document.getElementById('timerText');
    
    setInterval(() => {
        timeLeft--;
        timerText.innerText = `Auto-refresh: ${timeLeft}s`;
        if (timeLeft <= 0) {
            fetchInbox();
            timeLeft = 10;
        }
    }, 1000);
}
